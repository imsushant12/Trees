//by Sushant Gaurav

#include<stdio.h>
#include<stdlib.h>

struct node
{
    int info;
    struct node *left,*right;
    int height;
};

struct node* createnode(int data)
{
    struct node *tree;
    tree=(struct node*)malloc(sizeof(struct node));
    tree->left=NULL;
    tree->right=NULL;
    tree->info=data;
    tree->height=1;
    return tree;
}

int height(struct node *root)
{
    if(root == NULL)
        return NULL;
    else
        return root->height;
}

int max(int a,int b)
{
    return (a > b) ? a : b;
}

struct node* LLrotation(struct node *root)
{
    struct node *p1;                         //for adjustments
    struct node *p2;

    p1 = root;                               //A
    p2 = root->left;                         //B

    p1->left = p2->right;                    //A->left = B->right;
    p2->right = p1;                          //B->right = A;

    return p2;                               //new pointer i.e. B
}

struct node* RRrotation(struct node *root)
{
    struct node *p1;                         //for adjustments
    struct node *p2;

    p1 = root;                               //A
    p2 = root->right;                        //B

    p1->right = p2->left;                    //A->right = B->left;
    p2->left = p1;                           //B->left = A;

    return p2;                               //new pointer i.e. B
}

struct node* LRrotation(struct node *root)
{
    struct node *p1;
    struct node *p2;
    struct node *p3;

    p1 = root;                              //A
    p2 = root->left;                        //B
    p3 = root->left->right;                 //C

    p2->right = p3->left;                   //B->right = C->left
    p1->left = p3->right;                   //A->left = C->right
    p3->right = p1;                         //C->right = A
    p3->left = p2;                          //C->left = B

    return p3;                              //C is the new root
}

struct node* RLrotation(struct node *root)
{
    struct node *p1;
    struct node *p2;
    struct node *p3;

    p1 = root;                              //A
    p2 = root->right;                       //B
    p3 = root->right->left;                 //C

    p1->right = p3->left;                   //A->right = C->left
    p2->left = p3->right;                   //B->left = C->right
    p3->right = p2;                         //C->right = B
    p3->left = p1;                          //C->left =

    return p3;                              //C is the new root
}

int nodeheight(struct node* root)
{
    if(root && root->left)
    {
        if(root->left->height > root->right->height)
            return (root->left->height + 1);
    }
    else if(root && root->right)
    {
        if(root->right->height > root->left->height)
            return (root->right->height + 1);
    }
}

int BalanceFactor(struct node* root)
{
    if(root == NULL)
        return 0;
    else
        return(height(root->left) - height(root->right));
}

struct node* create(int data)
{
    struct node *newnode = (struct node*)malloc(sizeof(struct node));
    newnode->info = data;
    newnode->left = NULL;
    newnode->right = NULL;
    newnode->height = 1;
    return newnode;
}

struct node* AVLinsertion(struct node* root , int data)
{
    if(root == NULL)
    {
        root = create(data);
        return root;
    }

    else if(data < root->info)
    {
        root->left = AVLinsertion(root->left , data);
    }

    else
    {
        root->right = AVLinsertion(root->right , data);
    }
    //node's height will be max of (l-height,r-height) + 1
    root->height = max(height(root->left) , height(root->right));

    //Insertion is done now conditions for rotation if needed.
    if(BalanceFactor(root)==2 && BalanceFactor(root->left)==1)
        return LLrotation(root);

    if(BalanceFactor(root)==2 && BalanceFactor(root->left)==-1)
        return LRrotation(root);

    if(BalanceFactor(root)==-2 && BalanceFactor(root->left)==-1)
        return RRrotation(root);

    if(BalanceFactor(root)==-2 && BalanceFactor(root->left)==1)
        return RLrotation(root);



    return root;

}

void inorder(struct node* root)
{
    if(root == NULL)
        return;

    inorder(root->left);
    printf("%d  ",root->info);
    inorder(root->right);
}

int main()
{
    struct node *root = NULL;
    int data;
    while(1)
    {
        printf("\nEnter element or press -1 : ");
        scanf("%d",&data);
        if(data == -1)
            break;
        else
            root = AVLinsertion(root , data);
    }

    printf("\nInorder traversal of the tree formed = ");
    inorder(root);

    return 0;
}
